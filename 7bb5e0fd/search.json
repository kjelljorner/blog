[
  {
    "objectID": "posts/2022-07-17-orbitalets/index.html",
    "href": "posts/2022-07-17-orbitalets/index.html",
    "title": "Frontier molecular orbitalets",
    "section": "",
    "text": "Installation\nLibSC needs to be installed from source, and we need to have the following on our system\n\nC++ and C compilers\nThe Eigen library\nCMake\nOpenMP\nGNU Make or Ninja\n\nTo use the Python interface to PySCF, we also need to have these installed:\n\nPySCF\nNumPy\n\nI followed the installation instructions approximately. On my Mac, I would use\n$ CC=gcc-11 CXX=g++-11 cmake -B build -DCMAKE_BUILD_TYPE=Release\n$ cmake --build build -j 8 \nIf everything goes well, the build/src directory then needs to be added to the system path to allow import of the pyscf_losc module.\n\n\nCalculating the orbitalets\n\nimport sys\nsys.path.insert(0, \"/Users/kjelljorner/bin/losc/build/src\")\nimport os\n\nimport py3Dmol\nimport pyscf\nimport pyscf_losc\nfrom morfeus.conformer import _add_conformers_to_mol\nimport polanyi\nfrom polanyi.workflow import opt_xtb\nfrom pyscf import tools\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem\n\nos.environ[\"OMP_NUM_THREADS\"] = \"4\" # Adjust to how many processors you want PySCF and LibSC to use\npolanyi.config.OMP_NUM_THREADS = \"4\"\n\nFirst we generate coordinates for the molecule with RDKit and then optimize using GFN2-xTB. Here we use a convenience function from the polanyi package, soon to be released. The geometry refinement step with xtb can probably be skipped for illustration purposes.\n\n# Generate the molecule with RDKit\nsmiles = \"C/[N+](=C/C1=CC=CC=C1)/[O-]\"\nmol = Chem.MolFromSmiles(smiles)\nmol = Chem.AddHs(mol)\nAllChem.EmbedMolecule(mol)\nAllChem.MMFFOptimizeMolecule(mol)\n\n# Optimize with xtb\nelements = [atom.GetSymbol() for atom in mol.GetAtoms()]\ncoordinates = mol.GetConformer().GetPositions()\nopt_coordinates = opt_xtb(elements, coordinates)\n\n# Add the optimized coordinates back to the Mol for later visualization\nmol.RemoveAllConformers()\n_add_conformers_to_mol(mol, [opt_coordinates])\n\nWe then do a single-point calculation with PySCF. For illustration purposes, we use the small STO-3G basis set. For publication quality results, a larger basis set would of course need to be used. The PySCF calculation is quite fast, ca 7s on my computer.\n\n# Create PySCF Mole object\natoms = [(element, coordinate) for element, coordinate in zip(elements, opt_coordinates)]\npyscf_mole = pyscf.gto.Mole(basis=\"sto-3g\")\npyscf_mole.atom = atoms\npyscf_mole.symmetry = False  # turn off symmetry in PySCF\npyscf_mole.build()\n\n# Conduct the DFA SCF calculation from PySCF.\nmf = pyscf.scf.RKS(pyscf_mole)\nmf.xc = \"B3LYP\"\nmf.kernel();\n\nconverged SCF energy = -434.318630743168\n\n\nWe then calculate the orbitalets and their energies using LibSC.\n\n# Configure LOC calculation settings.\npyscf_losc.options.set_param(\"localizer\", \"max_iter\", 1000)\n\n# Conduct the post-SCF LOC calculation\n_, _, losc_data = pyscf_losc.post_scf_losc(\n    pyscf_losc.BLYP,\n    mf,  \n    return_losc_data = True\n)    \n\nThe orbital localization is not a cheap calculation and actually takes almost the same time as the SCF calculation, ca 8 s on my computer. We can now take a look at the orbitalet vs the orbital.\n\n\nVisualize the orbitalets\nWe will use py3Dmol to draw the orbitals and write a small convenience function that will do the heavy lifting\n\ndef draw_orbital(view, mol, filename):\n    with open(filename) as f:\n        cube_data = f.read()\n    view.addVolumetricData(cube_data, \"cube\", {'isoval': -0.04, 'color': \"red\", 'opacity': 0.75})\n    view.addVolumetricData(cube_data, \"cube\", {'isoval': 0.04, 'color': \"blue\", 'opacity': 0.75})\n    view.addModel(Chem.MolToMolBlock(mol), 'mol')\n    view.setStyle({'stick':{}})\n    view.zoomTo()\n    view.update()\n    view.clear()\n\nWe use PySCF to create cube files of the orbitals. We store both the HOMO, HOMOL, LUMO and LUMOL.\n\nhomo_idx = pyscf_mole.nelectron // 2 - 1\nlumo_idx = homo_idx + 1\norbitalets = losc_data[\"C_lo\"][0]\n_ = tools.cubegen.orbital(pyscf_mole, f'orbitalet_homo.cube', orbitalets[:,homo_idx],  nx=60, ny=60, nz=60)\n_ = tools.cubegen.orbital(pyscf_mole, f'orbital_homo.cube', mf.mo_coeff[:,homo_idx],  nx=60, ny=60, nz=60)\n_ = tools.cubegen.orbital(pyscf_mole, f'orbitalet_lumo.cube', orbitalets[:,lumo_idx],  nx=60, ny=60, nz=60)\n_ = tools.cubegen.orbital(pyscf_mole, f'orbital_lumo.cube', mf.mo_coeff[:,lumo_idx],  nx=60, ny=60, nz=60)\n\nWe can visualize the orbitals with py3Dmol. The HOMOL is significantly more localized than the HOMO.\n\nview = py3Dmol.view(width=400, height=400)\nview.show()\ndraw_orbital(view, mol, \"orbital_homo.cube\")\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\n\n\n\nview = py3Dmol.view(width=400, height=400)\nview.show()\ndraw_orbital(view, mol, \"orbitalet_homo.cube\")\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\n\n\nFor the LUMOL, this localization becomes even more evident\n\nview = py3Dmol.view(width=400, height=400)\nview.show()\ndraw_orbital(view, mol, \"orbital_lumo.cube\")\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\n\n\n\nview = py3Dmol.view(width=400, height=400)\nview.show()\ndraw_orbital(view, mol, \"orbitalet_lumo.cube\")\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\n\n\nI will leave it up to the reader to decide whether the HOMO/HOMOL and LUMO/LUMOL energies are “sufficiently” similar or not\n\nprint(f\"HOMO (eV): {losc_data['dfa_orbital_energy'][0][homo_idx]:.3f}\")\nprint(f\"HOMOL (eV): {losc_data['losc_dfa_orbital_energy'][0][homo_idx]:.3f}\")\nprint(f\"LUMO (eV): {losc_data['dfa_orbital_energy'][0][lumo_idx]:.3f}\")\nprint(f\"LUMOL (eV): {losc_data['losc_dfa_orbital_energy'][0][lumo_idx]:.3f}\")\n\nHOMO (eV): -2.831\nHOMOL (eV): -5.921\nLUMO (eV): 1.425\nLUMOL (eV): 4.198\n\n\n\n\n\n\n\n\nReuseCode free to use under an MIT license. For citation, use webpage address and access date."
  },
  {
    "objectID": "posts/2021-10-15-chiral-templating/index.html",
    "href": "posts/2021-10-15-chiral-templating/index.html",
    "title": "Assigning chiral information with SMARTS templates",
    "section": "",
    "text": "Code\nWe import the usual RDKit packages and turn on stereo annotion of the images.\n\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import AllChem\nIPythonConsole.drawOptions.addStereoAnnotation = True\nIPythonConsole.ipython_useSVG=True \n\nFirst we will generate the molecule without chiral information\n\nsmiles = \"C(Cl)(Br)CC\"\nmol = Chem.MolFromSmiles(smiles)\ndisplay(mol)\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nOur goal is to convert this molecule into the reference below, which has a R configuration of the stereocenter.\n\nsmiles_ref = \"Br[C@@H](Cl)CC\"\nmol_ref = Chem.MolFromSmiles(smiles_ref)\ndisplay(mol_ref)\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe construct a SMARTS pattern with chiral information that will match the stereocenter. RDKit’s visualization of SMARTS patterns is quite limited, and we could instead use SMARTSView to get a better view.\n\nsmarts = \"[C][C@@H]([Br])[Cl]\"\npattern = Chem.MolFromSmarts(smarts)\ndisplay(pattern)\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe use the GetSubstructMatch method to obtain the atom indices of mol that match the pattern. They will be listed in the order of the atoms in the SMARTS pattern. The display of the Mol object is automatically updated to show the matched atoms.\n\nmatch = mol.GetSubstructMatch(pattern)\nprint(\"Matched indices:\", match)\ndisplay(mol)\n\nMatched indices: (3, 0, 2, 1)\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe key feature for determining chiral tags in RDKit is the order of the bonds in the Mol object. We will therefore use the following strategy:\n\nReorder the bonds in the Mol object so that they match the order in the SMARTS pattern\nSet the chiral tags of each matched atom so that they match the SMARTS pattern\n\nFirst, we find the indices of the bonds in mol that match those in pattern:\n\nindices_matched = []\nfor bond in pattern.GetBonds():\n    i, j = bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()\n    bond = mol.GetBondBetweenAtoms(match[i], match[j])\n    indices_matched.append(bond.GetIdx())\nprint(\"Matched bond indices:\", indices_matched)\n\nMatched bond indices: [2, 1, 0]\n\n\nThen we reorder the bond indices from mol so that the matched bonds (a) come before the unmatched ones and (b) have the same order as in pattern\n\nindices_all = list(range(mol.GetNumBonds()))\nindices_rest = [i for i in indices_all if i not in indices_matched]\nindices_new = indices_matched + indices_rest\nprint(\"Rest of bond indices:\", indices_rest)\nprint(\"New bond index order:\", indices_new)\n\nRest of bond indices: [3]\nNew bond index order: [2, 1, 0, 3]\n\n\nTo actually reorder the bonds, we need to create an editable RWMol object. We (a) remove all the bonds and then (b) add them back together in the new order.\n\nrw_mol = Chem.RWMol(mol)\n\nbond_info = []\nfor bond in list(rw_mol.GetBonds()):\n    bond_info.append((bond.GetBeginAtomIdx(), bond.GetEndAtomIdx(), bond.GetBondType()))\n    rw_mol.RemoveBond(bond.GetBeginAtomIdx(), bond.GetEndAtomIdx())\n\nfor i in indices_new:\n    rw_mol.AddBond(*bond_info[i])\ndisplay(rw_mol)\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, we set the chiral tags of each matched atom to that of the SMARTS pattern and recover a new Mol object that matches the stereochemistry that we want.\n\nfor i, atom in enumerate(pattern.GetAtoms()):\n    chiral_tag = atom.GetChiralTag()\n    rw_mol.GetAtomWithIdx(match[i]).SetChiralTag(chiral_tag)\n    \nmol_new = rw_mol.GetMol()\nChem.SanitizeMol(mol_new)\nChem.AssignCIPLabels(mol_new)\n\nChem.Draw.MolsToGridImage([mol, mol_new, mol_ref], legends=[\"Original\", \"Templated\", \"Reference\"], molsPerRow=3, useSVG=True)\n\n\n\n\n\n\nFunction\nFinally we can put everything together in one function:\n\ndef apply_chiral_template(mol, pattern):\n    # Apply SMARTS pattern to Mol\n    match = mol.GetSubstructMatch(pattern)\n    \n    # Find indices of matched bonds in Mol\n    indices_matched = []\n    for bond in pattern.GetBonds():\n        i, j = bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()\n        bond = mol.GetBondBetweenAtoms(match[i], match[j])\n        indices_matched.append(bond.GetIdx())\n        \n    # Reorder bond indices to match SMARTS pattern\n    indices_all = list(range(mol.GetNumBonds()))\n    indices_rest = [i for i in indices_all if i not in indices_matched]\n    indices_new = indices_matched + indices_rest\n    \n    # Create new Mol. Delete and re-add bonds in new order\n    rw_mol = Chem.RWMol(mol)\n    \n    bond_info = []\n    for bond in list(rw_mol.GetBonds()):\n        bond_info.append((bond.GetBeginAtomIdx(), bond.GetEndAtomIdx(), bond.GetBondType()))\n        rw_mol.RemoveBond(bond.GetBeginAtomIdx(), bond.GetEndAtomIdx())\n    \n    for i in indices_new:\n        rw_mol.AddBond(*bond_info[i])\n    \n    # Set chiral tags from template to new Mol\n    for i, atom in enumerate(pattern.GetAtoms()):\n        chiral_tag = atom.GetChiralTag()\n        rw_mol.GetAtomWithIdx(match[i]).SetChiralTag(chiral_tag)\n        \n    # Recover new Mol\n    new_mol = rw_mol.GetMol()\n    Chem.SanitizeMol(new_mol)\n    \n    return new_mol\n\n\n\nMore complex example\nNow we will use the function on a more complex example with four stereocenters. Note that R and S labels depend on the CIP order of the substituents, which is not defined in terms of the wildcard atom “*”\n\nsmiles = \"CC1C(C)C2CCC1C2\"\nmol = Chem.MolFromSmiles(smiles)\n\nsmiles_ref = \"C[C@@H]1[C@H](C)[C@H]2CC[C@@H]1C2\"\nmol_ref = Chem.MolFromSmiles(smiles_ref)\n\nsmarts = \"[*]-[C@@H]1-[C@H](-[*])-[C@H]2-C-C-[C@@H]1-C2\"\npattern = Chem.MolFromSmarts(smarts)\nChem.SanitizeMol(pattern) # Needed to avoid bug in MolsToGridImage\n\nChem.Draw.MolsToGridImage([mol, mol_ref, pattern], legends=[\"Undefined\", \"Defined\", \"SMARTS\"], useSVG=True)\n\n\n\n\nTo get the right CIP labels, we need to apply the function AssignCIPLabels but that should not be crucial except for visualization.\n\nmol_new = apply_chiral_template(mol, pattern)\nChem.AssignCIPLabels(mol_new)\n\nChem.Draw.MolsToGridImage([mol, mol_new, mol_ref], legends=[\"Original\", \"Templated\", \"Reference\"], molsPerRow=3, useSVG=True)\n\n\n\n\n\n\n\n\n\n\nReuseCode free to use under an MIT license. For citation, use webpage address and access date."
  },
  {
    "objectID": "posts/2022-06-30-visualizing-atomic/index.html",
    "href": "posts/2022-06-30-visualizing-atomic/index.html",
    "title": "Visualizing atomic type orbitals in molecules",
    "section": "",
    "text": "Sometimes we need to display atomic type orbitals in a schematic way to visualize simple concepts. The molecular orbitals or even localized orbitals are then overly complex. Simple examples are the ChemDraw-style orbitals, which are used to rationalize reactions in organic chemistry. Now, is it possible to obtain similar orbitals, but in 3D?"
  },
  {
    "objectID": "posts/2022-06-30-visualizing-atomic/index.html#interactive-viewing",
    "href": "posts/2022-06-30-visualizing-atomic/index.html#interactive-viewing",
    "title": "Visualizing atomic type orbitals in molecules",
    "section": "Interactive viewing",
    "text": "Interactive viewing\nUnfortunately, the interactive viewer doesn’t display on the blog. Try running the code below on Binder or locally on your machine.\n\nfrom ipywidgets import fixed, interact_manual\n\nn_orbitals = naos.shape[1]\nview = py3Dmol.view(width=400,height=400)\nview.show()\ninteract_manual(draw_orbital, view=fixed(view), i=(1, n_orbitals));\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol"
  },
  {
    "objectID": "posts/2022-08-13-interactive/index.html",
    "href": "posts/2022-08-13-interactive/index.html",
    "title": "Interactive molecular content",
    "section": "",
    "text": "I recently rebased the blog on the Quarto publishing system. Quarto is an evolution of R Markdown and allows publishing a notebook (.qmd or .ipynb) in various formats, inlcuding as blog posts.\nIn the previous post on visualizing atomic type orbitals, we had some code for interactive visualization with ipywidgets. Unfortunately, it didn’t work in the browser as it needs a Python backend running. With Quarto as publishing system, we can work around that problem.\nThanks to the support for the Observable dialect of JavaScript (OJS) in Quarto, we can create interactive elements which will work on the final static webpage. This will require some level of proficiency with JavaScript, but rest assured that I knew zero JavaScript when I started writing this blog post. The code cells featuring OJS are hidden in this post, but can be shown by clicking on the arrow next to “Code”. But first we will start with a visualization that doesn’t need any JavaScript skills."
  },
  {
    "objectID": "posts/2022-08-13-interactive/index.html#visualing-molecules-with-molplotly",
    "href": "posts/2022-08-13-interactive/index.html#visualing-molecules-with-molplotly",
    "title": "Interactive molecular content",
    "section": "Visualing molecules with molplotly",
    "text": "Visualing molecules with molplotly\nmolplotly is a great add-on to plotly to display data together with 2D images of the associated molecules. It is really easy to use and works nicely in a Jupyter Notebook, but requires a Dash app to run in the background. Here we will instead use Bokeh to create similar plots which can be displayed on a static webpage, although with a bit more effort. See the Bokeh documentation as well as the blog post by iwatobipen and the notebook from OpenEye Software for more ideas.\nWe visualize the ESOL dataset,1 downloaded from MoleculeNet.\n\nfrom bokeh.io import output_notebook\nfrom bokeh.models import HoverTool\nfrom bokeh.plotting import figure, show, ColumnDataSource\nimport pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem\n\n# Read the csv file\ndf = pd.read_csv(\"delaney-processed.csv\")\n\n# Get data to plot\nall_smiles = df[\"smiles\"]\nx = df[\"measured log solubility in mols per litre\"].values\ny = df[\"Molecular Weight\"].values\n\n# Create SVGs for each smiles with the \"new\" RDKit drawing code\nimgs = []\nfor smiles in all_smiles:\n    mol = Chem.MolFromSmiles(smiles)\n    d2d = Chem.Draw.MolDraw2DSVG(150, 150)\n    d2d.DrawMolecule(mol)\n    d2d.FinishDrawing()\n    svg = d2d.GetDrawingText()\n    imgs.append(svg)\n\n# Configure for output in the notebook\noutput_notebook()\n\n# Load the data into a source and plot\nsource = ColumnDataSource(\n    data={\n        \"x\": x,\n        \"y\": y,\n        \"imgs\": imgs,\n        \"smiles\": all_smiles,\n    }\n)\np = figure()\np.scatter(\"x\", \"y\", source=source)\np.plot_height = 300\np.plot_width = 400\np.sizing_mode = \"scale_width\"\np.xaxis.axis_label = \"Molecular weight\"\np.yaxis.axis_label = \"log S\"\n\n# Create tooltips referencing stored images\nTOOLTIPS = \"\"\"\\\n    <div>\n        <div>\n            @imgs{safe}\n        </div>\n        <div>\n            <span>[$index]</span>\n        </div>\n        <div>\n            <span>@smiles{safe}</span>\n        </div>\n        <div>\n            <span>($x, $y)</span>\n        </div>\n    </div>\n\"\"\"\n\n# Connect tooltips to plot\np.add_tools(HoverTool(tooltips=TOOLTIPS))\n\n# Show figure\nshow(p)\n\n\n        \n        Loading BokehJS ..."
  },
  {
    "objectID": "posts/2022-08-13-interactive/index.html#visualizing-different-conformers",
    "href": "posts/2022-08-13-interactive/index.html#visualizing-different-conformers",
    "title": "Interactive molecular content",
    "section": "Visualizing different conformers",
    "text": "Visualizing different conformers\nAs a second exercise, we are going to create a number of conformers for the propanal molecule using morfeus. We save one file with lowest energy conformer and one file with all the conformers. The function ojs_define is special to Quarto and allows passing data from Python or R to OJS. We use it to send over a list of the conformer energies for later display.\n\nfrom morfeus.conformer import ConformerEnsemble, _extract_from_mol\nfrom morfeus.io import write_xyz\n\n# Optimize propanal conformers\nsmiles = \"CCC=O\"\nce = ConformerEnsemble.from_rdkit(smiles, optimize=\"MMFF94\", random_seed=42)\nce.prune_rmsd()\nce.sort()\n\n# Write out conformers\nce.write_xyz(\"lowest.xyz\", ids=[0])\nce.align_conformers()\nelements, conformer_coordinates, _, _ = _extract_from_mol(ce.mol)\nwrite_xyz(\"conformers.xyz\", elements, conformer_coordinates)\n\n# Send variables to OJS\nojs_define(confEnergies=list(ce.get_relative_energies()))\n\n\nNow we will create the interactive visualization with 3Dmol.js.2 We will first create an input slider to allow the reader to select which conformer to show. This is done with Inputs.range in OJS (click “Code” to reveal the OJS code). We then use 3DMol.js to load the conformers.xyz file and define the function updateViewer which we couple to the input slider. There is a Python interface to 3Dmol called py3Dmol, but it currently cannot generate the level of interactivity that we need.\nWe create a slider to choose the conformer, and a reactive label that prints the energy of the currently selected conformer.\n\n\nCode\nviewof confIDInput = Inputs.range([1, confEnergies.length], {value: 1, step: 1, label: \"Conformer ID\"});\nmd`Energy (kcal/mol): ${confEnergies[confIDInput - 1].toFixed(3)}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n// Create container\ndivConf = html`<div style=\"width:${layoutWidth[\"layout-conf\"]}px;height:${layoutWidth[\"layout-conf\"] * 2 / 3}px;position:relative\"></div>`;\n\n\n\n\n\n\n\n\n\n\nCode\njquery = require(\"jquery\");\n$3Dmol = require(\"3dmol\");\nNGL = require(\"ngl@next\");\n\n// Create viewer\nviewerConf = {\n  let xyzString = await FileAttachment(\"conformers.xyz\").text();\n  let viewer = $3Dmol.createViewer(divConf, {});\n  viewer.addModelsAsFrames(xyzString, \"xyz\");\n  viewer.setStyle({stick:{}});\n  viewer.zoomTo();\n  viewer.render();\n  return viewer;\n};\n\nupdateViewer = function(viewer, ID){\n  viewer.setFrame(ID);\n  viewer.render();\n  return viewer;\n};\n\nupdateViewer(viewerConf, confIDInput - 1);"
  },
  {
    "objectID": "posts/2022-08-13-interactive/index.html#optimization-trajectory",
    "href": "posts/2022-08-13-interactive/index.html#optimization-trajectory",
    "title": "Interactive molecular content",
    "section": "Optimization trajectory",
    "text": "Optimization trajectory\nNext we will display the results of a geometry optimization. To do the optimization we are going to use the PyBerny package, which is a partial Python re-implementation of the algorithm described by Bernhard Schlegel and co-workers.3.\nWe then use PyBerny together with the MOPAC backend to optimize the molecule. MOPAC is nowadays available for free and can be installed with conda.\n$ conda install -c conda-forge mopac\nWe store all the energies and coordinates and write an xyz file with the whole optimization trajectory. wurlitzer is needed to suppress some output from MOPAC.\n\nfrom berny import Berny, geomlib\nfrom berny.solvers import MopacSolver\nfrom wurlitzer import pipes\nfrom morfeus.io import write_xyz\nfrom morfeus.data import HARTREE_TO_KCAL, HARTREE_TO_EV\n\noptimizer = Berny(geomlib.readfile(\"lowest.xyz\"))\nsolver = MopacSolver()\nnext(solver)\ntraj = []\nenergies = []\nwith pipes() as (stdout, stderr):\n    for geom in optimizer:\n        energy, gradients = solver.send((list(geom), geom.lattice))\n        optimizer.send((energy, gradients))\n        traj.append(geom)\n        energies.append(energy)\nenergies = [\n    (energy - energies[-1]) * HARTREE_TO_KCAL + 1e-8 for energy in energies\n]  # add small energy to avoid bug in observable plot\nwrite_xyz(\"traj.xyz\", traj[0].species, [geom.coords for geom in traj])\n\nNow we want to calculate some additional information to use in the visualization. That includes the bond lenghts of the C1–C2 bond for each step of the trajectory, which we store in labels. We also pass over the data on the energies for each step as a Pandas DataFrame.\n\nfrom morfeus.io import read_xyz\nimport scipy.spatial\nimport pandas as pd\n\n# Calculate the bond distance labels\n_, coordinates = read_xyz(\"traj.xyz\")\nlabels = [scipy.spatial.distance_matrix(coord, coord)[0, 1] for coord in coordinates]\n\n# Pass the variables onto Observable\nopt_data = pd.DataFrame({\"step\": range(1, len(energies) + 1), \"energy\": energies})\nojs_define(labels=labels, optData=opt_data)\n\n\nTo be able to animate the trajectory we need to use a special type of input object that is not part of the standard Observable inputs. Luckily, the Observable creator Mike Bostock has created the Scrubber for us to do this work and we can easily import it.\n\n\nCode\nimport {Scrubber} from \"@mbostock/scrubber\"\nnumbers = Array.from({length: labels.length}, (_, i) => i + 1);\nviewof frameIDInput = Scrubber(numbers, {delay: 500, autoplay: false})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n// Create drawing area\ndivBerny = html`<div style=\"width:${layoutWidth[\"layout-berny\"] / 2}px;height:${layoutWidth[\"layout-berny\"] / 3}px;position=\"relative\"></div>`;\n\n\n\n\n\n\n\n\n\nCode\nplot = Plot.plot({\n  x: {label: \"→ Step\"},\n  y: {label: \"↑ Energy (kcal/mol)\"},\n  style: {fontSize: 20},\n  margin: 50,\n  marks: [\n    Plot.line(transpose(optData), \n      { x: \"step\", y: \"energy\"}, \n      { stroke: \"black\" }\n    ),\n    Plot.dot(transpose(optData), Plot.select(I => [frameIDInput - 1], {x: \"step\", y: \"energy\"})),\n    Plot.text(transpose(optData), Plot.select(I => [frameIDInput - 1], {x: \"step\", y: \"energy\", text: \"energy\", dx: 10, dy: -10}))\n  ]}\n);\n\n\n\n\n\n\n\n\n\n\n\nCode\nviewerBerny = {\n  let xyzString = await FileAttachment(\"traj.xyz\").text();\n  let viewer = $3Dmol.createViewer(divBerny);\n  viewer.addModelsAsFrames(xyzString, \"xyz\");\n  viewer.setStyle({stick: {}});\n  for (let i = 0; i < viewer.getNumFrames(); i++) {\n      viewer.addLabel(labels[i].toFixed(3), {alignment: \"center\", frame: i}, {serial: [1, 2]});\n  };  \n  viewer.zoomTo();\n  viewer.render();\n  return viewer;\n};\n\n// Update the view\nupdateViewer(viewerBerny, frameIDInput - 1)"
  },
  {
    "objectID": "posts/2022-08-13-interactive/index.html#molecular-orbitals",
    "href": "posts/2022-08-13-interactive/index.html#molecular-orbitals",
    "title": "Interactive molecular content",
    "section": "Molecular orbitals",
    "text": "Molecular orbitals\nWe’re now ready to tackle the interactive visualization of molecular orbitals. We again use PySCF to generate them. We send over the orbital occupations numbers and energies for display with OJS.\n\nimport pyscf\nfrom pyscf import gto, lo, tools, dft\n\nelements, coordinates = read_xyz(\"lowest.xyz\")\natoms = [(element, coordinate) for element, coordinate in zip(elements, coordinates)]\npyscf_mole = gto.Mole(basis=\"sto-3g\")\npyscf_mole.atom = atoms\npyscf_mole.build()\n\nmf = dft.RKS(pyscf_mole)\nmf.xc = \"b3lyp\"\nmf.run()\n\nn_orbs = mf.mo_coeff.shape[1]\nfor i in range(n_orbs):\n    tools.cubegen.orbital(\n        pyscf_mole, f\"mo_{i+1:02d}.cube\", mf.mo_coeff[:, i], nx=40, ny=40, nz=40\n    )\n\nhomo_ID = pyscf_mole.nelectron // 2\nmo_energies = list(mf.mo_energy * HARTREE_TO_EV)\nmo_data = pd.DataFrame({\"energy\": mo_energies})\nojs_define(\n    MOOccs=list(mf.mo_occ), MOEnergies=mo_energies, homoID=homo_ID, MOData=mo_data\n)\n\n\nWe now create a slider to select the MO number, as well as an input box to select the isodensity surface value. We show both the orbitals, and a “tick” plot made with Observable Plot to show were the selected orbital lies in the manifold.\n\n\nCode\nviewof MOIDInput = Inputs.range([1, MOOccs.length], {value: homoID, step: 1, label: \"MO ID\"});\nviewof MOIsoInput = Inputs.number([0.0, Infinity], {value: 0.04, step: 0.0001, label: \"Isodensity value\"});\nmd`Occ: ${MOOccs[MOIDInput - 1]}  \nEnergy (eV): ${MOEnergies[MOIDInput - 1].toFixed(3)}`;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n// Create drawing area\ndivMO = html`<div style=\"width:${layoutWidth[\"layout-mo\"] / 2}px;height:${layoutWidth[\"layout-mo\"] / 3}px;position=\"relative\"></div>`;\n\n\n\n\n\n\n\n\n\nCode\nplot_mo = Plot.plot({\n  y: {\n    domain: [-30, d3.max(MOData[\"energy\"])],\n    label: \"↑ Energy (eV)\"\n  },\n  style: {fontSize: 20},  \n  margin: 40,\n  marks: [\n    Plot.tickY(transpose(MOData), {y: \"energy\"}),\n    Plot.tickY(transpose(MOData), Plot.select(I => [MOIDInput - 1], {y: \"energy\", strokeWidth: 3}))\n  ]}\n);\n\n\n\n\n\n\n\n\n\n\n\nCode\nMOStrings = [ \n    await FileAttachment(\"mo_01.cube\").text(),\n    await FileAttachment(\"mo_02.cube\").text(),\n    await FileAttachment(\"mo_03.cube\").text(),\n    await FileAttachment(\"mo_04.cube\").text(),\n    await FileAttachment(\"mo_05.cube\").text(),\n    await FileAttachment(\"mo_06.cube\").text(),\n    await FileAttachment(\"mo_07.cube\").text(),\n    await FileAttachment(\"mo_08.cube\").text(),\n    await FileAttachment(\"mo_09.cube\").text(),\n    await FileAttachment(\"mo_10.cube\").text(),\n    await FileAttachment(\"mo_11.cube\").text(),\n    await FileAttachment(\"mo_12.cube\").text(),\n    await FileAttachment(\"mo_13.cube\").text(),\n    await FileAttachment(\"mo_14.cube\").text(),\n    await FileAttachment(\"mo_15.cube\").text(),\n    await FileAttachment(\"mo_16.cube\").text(),\n    await FileAttachment(\"mo_17.cube\").text(),\n    await FileAttachment(\"mo_18.cube\").text(),\n    await FileAttachment(\"mo_19.cube\").text(),\n    await FileAttachment(\"mo_20.cube\").text(),\n    await FileAttachment(\"mo_21.cube\").text(),\n    await FileAttachment(\"mo_22.cube\").text(),\n    await FileAttachment(\"mo_23.cube\").text(),\n    await FileAttachment(\"mo_24.cube\").text(),\n    await FileAttachment(\"mo_25.cube\").text(),\n    await FileAttachment(\"mo_26.cube\").text()\n]\n\n// Create viewer\nviewerMO = {\n  let xyzString = await FileAttachment(\"lowest.xyz\").text();\n  let viewer = $3Dmol.createViewer(divMO, {});\n  viewer.addModelsAsFrames(xyzString.repeat(MOOccs.length), \"xyz\");\n  viewer.setStyle({stick: {}});\n  for (let i = 0; i < MOOccs.length; i++) {\n    viewer.addVolumetricData(MOStrings[i], \"cube\", {\"isoval\": -MOIsoInput, \"color\": \"red\", \"opacity\": 0.8, frame: i});\n    viewer.addVolumetricData(MOStrings[i], \"cube\", {\"isoval\": MOIsoInput, \"color\": \"blue\", \"opacity\": 0.8, frame: i});\n    viewer.render();    \n  };    \n  viewer.zoomTo();\n  viewer.render();\n  return viewer;\n};\n\nupdateViewer(viewerMO, MOIDInput - 1);"
  },
  {
    "objectID": "posts/2022-08-13-interactive/index.html#surface-properties",
    "href": "posts/2022-08-13-interactive/index.html#surface-properties",
    "title": "Interactive molecular content",
    "section": "Surface properties",
    "text": "Surface properties\n3Dmol can also be used to display surfaces. Here we generate the total electron density and the electrostatic potential as cube files.\n\ndm = mf.make_rdm1()\ntools.cubegen.density(pyscf_mole, \"density.cube\", dm,  nx=40, ny=40, nz=40)\ntools.cubegen.mep(pyscf_mole, \"esp.cube\", dm,  nx=40, ny=40, nz=40)\n\nWe then create a visualization of the surface and an input box to select the isodensity value.\n\n\nCode\n// Create input slider\nviewof isoInput = Inputs.number([0.0, Infinity], {value: 0.001, step: 0.0001, label: \"Isodensity value\"});\n\n\n\n\n\n\n\n\n\n\nCode\n\n// Create drawing area\ndivDensity = html`<div style=\"width:${layoutWidth[\"layout-density\"]}px;height:${layoutWidth[\"layout-density\"] * 2 / 3}px;position:relative\"></div>`;\n\n\n\n\n\n\n\n\n\n\nCode\nviewerDensity = {\n  let xyz_string = await FileAttachment(\"lowest.xyz\").text();\n  let viewer = $3Dmol.createViewer(divDensity, {});\n  viewer.addModel(xyz_string, \"xyz\");\n  viewer.setStyle({stick: {}});\n  viewer.zoomTo();\n  viewer.render();\n  return viewer;\n};\n\nadd_iso = function(viewer, voldata, isoValue) {\n  viewer.removeAllShapes();\n  viewer.addIsosurface(voldata, {isoval: isoValue, color: \"lightgray\", opacity:0.85});\n  viewer.render();\n};\n\n{\n  let densityString = await FileAttachment(\"density.cube\").text();\n  let voldata = new $3Dmol.VolumeData(densityString, \"cube\");\n  add_iso(viewerDensity, voldata, isoInput);\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can do the same thing with an electrostatic potential (ESP) surface, where we map the ESP onto an isodensity surface.\n\n\nCode\n// Create input object\nviewof ESPInput = Inputs.number([0.0, Infinity], {value: 0.001, step: 0.0001, label: \"Isodensity value\"});\n\n\n\n\n\n\n\n\n\n\nCode\ndiv_ESP = html`<div style=\"width:${layoutWidth[\"layout-esp\"]}px;height:${layoutWidth[\"layout-esp\"] * 2 / 3}px;position:relative\"></div>`;\n\n// Create a color legend\nPlot.legend({label: \"esp\", color: {scheme: \"rdbu\", domain: [-1, 1]}, width: layoutWidth[\"layout-esp\"] / 3})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nviewerESP = {\n  let xyzString = await FileAttachment(\"lowest.xyz\").text();\n  let viewer = $3Dmol.createViewer(div_ESP, {});\n  viewer.addModelsAsFrames(xyzString, \"xyz\");\n  viewer.setStyle({stick: {}});\n  viewer.zoomTo();\n  viewer.render();\n  return viewer;\n};\n\n// Create function to add ESP to viewer\nadd_esp = function(viewer, densityString, espString, isoValue) {\n  viewer.removeAllShapes();\n  viewer.addVolumetricData(densityString, \"cube\", {\"isoval\": isoValue, \"smoothness\": 2, \"opacity\": 0.95, \"voldata\": espString, \"volformat\": \"cube\", \"volscheme\": {\"gradient\":\"rwb\", \"min\":-.1, \"max\":.1}});\n  viewer.render();\n};\n\n// Draw the ESP\n{\n  let densityString = await FileAttachment(\"density.cube\").text();\n  let espString = await FileAttachment(\"esp.cube\").text();\n  add_esp(viewerESP, densityString, espString, ESPInput);\n}"
  },
  {
    "objectID": "posts/2022-08-13-interactive/index.html#ngl",
    "href": "posts/2022-08-13-interactive/index.html#ngl",
    "title": "Interactive molecular content",
    "section": "NGL",
    "text": "NGL\nAn alternative to 3Dmol is NGL.4 There is a very nice IPython/Jupyter widget called nglview that is based on NGL. Unfortunately, I also couldn’t get functionalities like the Trajectory to work interactively. Therefore we work around this and use the NGL library directly with JavaScript and make our own interactive controls as we did above for 3Dmol.\nFirst we need to create a structure file that can be read by NGL. The PDB format is most convenient for this purpose and we use Atomic Simulation Environment to help us rewrite the multi-structure xyz file to a multi-structure pdb file.\n\nimport ase.io\n\ntraj = [atoms for atoms in ase.io.iread(\"conformers.xyz\")]\nase.io.write(\"confomers.pdb\", traj)\n\nWe are now ready to visualize the PDB file with NGL.\n\n\nCode\nviewof trajInput = Inputs.range([1, confEnergies.length], {value: 1, step: 1, label: \"Conformer ID\"});\nmd`Energy (kcal/mol): ${confEnergies[trajInput - 1].toFixed(3)}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n// Create drawing area\ndivNGL = html`<div style=\"width:${layoutWidth[\"layout-ngl\"]}px;height:${layoutWidth[\"layout-ngl\"] * 2 / 3}px;position:relative\"></div>`;\n\n\n\n\n\n\n\n\n\n\nCode\ntrajPDB = {\n  let stage = new NGL.Stage(divNGL, {clipDist: 0.0, backgroundColor: \"white\"});\n  let pdbString = await FileAttachment(\"confomers.pdb\").blob();\n  let structure = await stage.loadFile(pdbString, {ext: \"pdb\", asTrajectory: true})\n  let traj = structure.addTrajectory().trajectory\n  structure.addRepresentation(\"licorice\");\n  structure.autoView();\n  return traj;\n};\n\n// Create function to update trajectory\nupdate_traj = function(traj, id){\n  traj.setFrame(id)\n};\n\n// Update trajectory based on slider\nupdate_traj(trajPDB, trajInput - 1);"
  },
  {
    "objectID": "posts/2022-08-13-interactive/index.html#references",
    "href": "posts/2022-08-13-interactive/index.html#references",
    "title": "Interactive molecular content",
    "section": "References",
    "text": "References\n\n\n(1) Delaney, J. S. ESOL: Estimating Aqueous Solubility Directly from Molecular Structure. J. Chem. Inf. Comput. Sci. 2004, 44 (3), 1000–1005. https://doi.org/10.1021/ci034243x.\n\n\n(2) Rego, N.; Koes, D. 3Dmol.js: Molecular Visualization with WebGL. Bioinformatics 2015, 31 (8), 1322–1324. https://doi.org/10.1093/bioinformatics/btu829.\n\n\n(3) Birkholz, A. B.; Schlegel, H. B. Exploration of Some Refinements to Geometry Optimization Methods. Theor. Chem. Acc. 2016, 135 (4), 84. https://doi.org/10.1007/s00214-016-1847-3.\n\n\n(4) Nguyen, H.; Case, D. A.; Rose, A. S. NGLview–Interactive Molecular Graphics for Jupyter Notebooks. Bioinformatics 2018, 34 (7), 1241–1242. https://doi.org/10.1093/bioinformatics/btx789."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Valence Kjell",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nInteractive molecular content\n\n\nHow to embed interactive content in webpages with Quarto using Bokeh, 3DMol.js and NGL\n\n\n\n\n\n\nAug 13, 2022\n\n\nKjell Jorner\n\n\n\n\n\n\n  \n\n\n\n\nFrontier molecular orbitalets\n\n\nHow to compute and visualize orbitalets with PySCF\n\n\n\n\n\n\nJul 17, 2022\n\n\nKjell Jorner\n\n\n\n\n\n\n  \n\n\n\n\nVisualizing atomic type orbitals in molecules\n\n\nHow to compute and visualize natural atomic orbitals with PySCF\n\n\n\n\n\n\nJun 30, 2022\n\n\nKjell Jorner\n\n\n\n\n\n\n  \n\n\n\n\nAssigning chiral information with SMARTS templates\n\n\nHow to transform an achiral molecule into a chiral based on a chiral template in RDKit\n\n\n\n\n\n\nOct 15, 2021\n\n\nKjell Jorner\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Kjell Jorner",
    "section": "",
    "text": "From January 2023, I will be an Assistant Professor of Digital Chemistry at ETH Zurich.\nAll views my own."
  }
]